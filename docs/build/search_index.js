var documenterSearchIndex = {"docs":
[{"location":"ThermovisorImages/#Functions-and-types-of-ThermovisorImages","page":"API","title":"Functions and types of ThermovisorImages","text":"","category":"section"},{"location":"ThermovisorImages/#ThermovisorImages.ThermovisorImages","page":"API","title":"ThermovisorImages.ThermovisorImages","text":"ThermovisorData is a package designed to process thermal images stored as matrices.\n\nEach  element of thermal image represents a temperature value. The package enables users to  load images from files, calculate temperature distributions, compute statistical analyses for temperatures along specified lines and recalculate the temperature by taking into account the  emissivity and spectral range of thermal imaging camera.  \n\nThermal image can be loaded using read_temperature_file. User defined matrix can be wrapped in RescaledImage which simple maps the values to [0,1] interval.  After that, distinct areas (relative to their surroundings,like the most heated regions within the scene) can be fitted to regions of interest (ROIs) using fit_all_patterns.  Temperature distribution along the specified lined within each ROI can be obtained, and average radial and There is also possible to evaluate the averaged statistics  over the fitted ROI's using CentredObjCollectionStat and recalculate the temperature for a new emissivity value of the whole image or it's region using recalculate_with_new_emissivity!\n\n\n\n\n\n\n\n","category":"module"},{"location":"ThermovisorImages/#Core.Type-Union{Tuple{}, Tuple{T}} where T<:CentredObj","page":"API","title":"Core.Type","text":"(::Type{T})() where T<:CentredObj\n\nEmpty object constructor\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.CentredObj","page":"API","title":"ThermovisorImages.CentredObj","text":"`CentredObj` is a sort of region of interest (ROI) marker object with coordinates and dimensions.\n\nCentredObj has centre coordinates and dimensions, object's center can be  anywhere with respect to the image indices. ROI also has one or more size parameters (in pixels) coordinates of centre are equal to CartesianIndices, first element is the row index,  the second element is the column index!! (y and x coordinate) This is opposite to the ImageDraw, where first Point coordinate corresponds to the column index and  the second one to the row index. CentredObj can also be used as for indexing image[c] - returns all elements of image within c, image[c]=x sets all elements of image to the values of x, x firstindex  should be 1. CentredObj can also be used to set all image points within the ROI to a single value. e.g. image[c] = 30 \n\nBy default we have three CentredObj types in package: \n\nCircleObj, SquareObj and RectangleObj\n\nTo impement CentredObj abstraction one needs to implement:\n\nside - returns what is assumed to be the single number characterisation of the dimensions (by default the maximum value of dimensions(c) is taken)\n\narea - returns the CentredObj area, used in statistics calculation and in default two objs compirason see isless(c1::CentredObj,c2::CentredObj)\n\nperimeter - Object's perimeter\n\nBase.size - should always return the minimum size of frame which wrappes the centred obj, e.g. for circle it is [diameter,diemater]\n\nis_within - function to check if inds are within the CentredObj\n\nline_within_mask - function to check if all line points are within the CentredObj\n\nfill_x0! - function to fill the optimization starting vector during CentredObj  fitting the image\n\nconvert_to_drawable fucntion to convert the CentredObj to a drawable obj for ImageDraw\n\nparnumber function which returns the number of parameters     \n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.CentredObjCollectionStat","page":"API","title":"ThermovisorImages.CentredObjCollectionStat","text":"CentredObjCollectionStat\n\nCalculates the following statistics on CentredObjs collection:\n\nminimal, maximal, mean and standard deviation of sides,areas and perimeters of all CentredObj objects in the collection v.\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.CircleObj","page":"API","title":"ThermovisorImages.CircleObj","text":"Circle object with defined diameter\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.DistributionStatistics","page":"API","title":"ThermovisorImages.DistributionStatistics","text":"DistributionStatistics\n\nBasic descriptive statistics (mean and standard deviation) on temeprature distribution  of value for a given coordinate,   D is the matrix of distribution, where each column corresponds to sample, thus rows number of D should be the same as the length  of coordinate, columns number is the number of samples.\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.FilteredImage","page":"API","title":"ThermovisorImages.FilteredImage","text":"    Type to store image with filtered temperature region\n\nFields:\n\nfull - filtered rescaled image of the same size as the input with all pixels which are not the part of the pattern with label value \n\nregion_indices - cartesian indices of the pattern in the input image\n\nreduced - image of reduced size where all not-inpatter pixels removed       (the \tscaling of this image is the same as of the input imag.initial      see RescaledImage type )\n\nreduced_flag - bitmatrix or Matrix{Bool} version of (reduced image)\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.MarkeredImage","page":"API","title":"ThermovisorImages.MarkeredImage","text":"Special type to work with segmentated image, stored the matrix of indices and a vector of vectors of\n\npatterns coordinates. Pattern can be sorted by area. And accessed by direct indexing into the MarkeredImage object.\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.RectangleObj","page":"API","title":"ThermovisorImages.RectangleObj","text":"Rectangular object with defined two sides\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.RescaledImage","page":"API","title":"ThermovisorImages.RescaledImage","text":"    RescaledImage - structure stores the image data mapped to region  [0,1]\n\nFields:\n\ninitial  - initial image before rescaling\n\nsz - size of the image\n\nmin - minimum value\n\nmax  - maximum value\n\nim - image with all values from 0 to 1 \n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.SquareObj","page":"API","title":"ThermovisorImages.SquareObj","text":"Square with defined center and side\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#ThermovisorImages.StatDataPlot","page":"API","title":"ThermovisorImages.StatDataPlot","text":"Type for custom plot recipe\n\n\n\n\n\n","category":"type"},{"location":"ThermovisorImages/#Base.getindex-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"Base.getindex","text":"Base.getindex(img::AbstractMatrix,c::CentredObj)\n\nCentredObj can be used for matrix indexing, image[centred_object] - returns the vector  of temperatures of all points of image lying within the centred_object of CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.isless-Tuple{CentredObj, CentredObj}","page":"API","title":"Base.isless","text":"Base.isless(c1::CentredObj,c2::CentredObj)\n\nBy default centred objects are compared by their areas, thus the vector of centred objects can be sorted\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.length-Tuple{MarkeredImage}","page":"API","title":"Base.length","text":"Base.length(m::MarkeredImage)\n\nReturn the total number of patterns in the markerred image MarkeredImage\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.length-Tuple{T} where T<:CentredObj","page":"API","title":"Base.length","text":"Base.length(c::CentredObj)\n\nTotal number of values needed to create CentredObj of specified type\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.setindex!-Tuple{Matrix, Array, CentredObj}","page":"API","title":"Base.setindex!","text":"Base.setindex!(img::Matrix,x::Array,c::CentredObj)\n\nimg[c]=x assignes all x elements to the elements of img with indices lying within the CentredObj c\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.setindex!-Union{Tuple{T}, Tuple{Matrix{T}, Number, CentredObj}} where T","page":"API","title":"Base.setindex!","text":"Base.setindex!(img::Matrix{T},x::Number,c::CentredObj) where T\n\nSetting all elements within the CentredObj to a single value\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#Base.size-Tuple{MarkeredImage}","page":"API","title":"Base.size","text":"Base.size(m::MarkeredImage)\n\nThe image size in pixels\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages._inbounds_flag-NTuple{4, Any}","page":"API","title":"ThermovisorImages._inbounds_flag","text":"_inbounds_flag(L,D,max_length,min_length)\n\nUnsafe version of check! number of  rows in D should be the same as the number of  elements in L Returns Bool flag of all row not containing NaN's and lying within the minlength to maxlength range\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages._to_rgb-Tuple{Matrix{Float64}}","page":"API","title":"ThermovisorImages._to_rgb","text":"_to_rgb(image::Matrix{Float64};\n    color_scheme::Symbol=:none)\n\nVersion without rescaling\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.add_distrib_point!-NTuple{4, Any}","page":"API","title":"ThermovisorImages.add_distrib_point!","text":"add_distrib_point!(points,distrib,point,value)\n\nInternal fucntion to add the point to distribution\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.along_line_distribution-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vararg{Any, 4}}} where T","page":"API","title":"ThermovisorImages.along_line_distribution","text":"along_line_distribution(img::AbstractMatrix{T},x0,y0,x1,y1) where T\n\nFunction evaluates matrix values distribution along the line specified by two coordinates,  img - input image  returns the tuple of two vectors: coordinates and values  see ImageDraw.bresenham for details of finding the points of the line \n\nreturns  points - vector of coordinates along the line distrib - distribution\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.along_line_distribution_plot-Tuple{Any, Any}","page":"API","title":"ThermovisorImages.along_line_distribution_plot","text":"along_line_distribution_plot(along_line_length,along_line_distribution;\n                                    length_scaler::Float64=1.0,\n                                    is_centered::Bool=true,\n                                    kwargs...)\n\nPlots temperature distribution along the line along_line_length - coordinates, along_line_distribution - values of temperature, length_scaler - length scaler  (can be used to convert pixels to the actual length) is_centered - the line length is converted to the coordinates with zero value in  the centre of the CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.along_line_distribution_xiaolin_wu-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vararg{Any, 4}}} where T","page":"API","title":"ThermovisorImages.along_line_distribution_xiaolin_wu","text":"along_line_distribution_xiaolin_wu(img::AbstractMatrix{T}, y0, x0, y1, x1) where T\n\nEvaluates the value matrix content along the line with endpoint coordinates x0,y0,y1,x1, returns indices of all points. As far as Wu's algorithm returns two adjacent points the value is evaluated as an average of two point obtained with Wu's algorithm\n\nsee  xiaolin_wu function from ImageDraw \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.along_mask_line_distribution","page":"API","title":"ThermovisorImages.along_mask_line_distribution","text":"along_mask_line_distribution(imag::AbstractMatrix,c::CentredObj,direction_angle=0.0,line_length=10.0;\n                                                                                        length_per_pixel=1.0,\n                                                                                        use_wu::Bool=false)\n\nThe same as within_mask_line_points_distribution but returns the line length along the coordinates within the  image.\n\nline_length - the length of line in the same units as length_per_pixel. The calibration using mm_per_pixel`, returns calibrated length along the line \n\n\n\n\n\n","category":"function"},{"location":"ThermovisorImages/#ThermovisorImages.angular_distribution_statistics-Tuple{Any, Any, Any}","page":"API","title":"ThermovisorImages.angular_distribution_statistics","text":"angular_distribution_statistics(angles,along_length_coordinate,distrib;\n                        max_length=-1.0,min_length=-1.0)\n\nFills DistributionStatistics object for angular\n\nOptional:\n\nmax_length - maximal value of alonglengthcoordinate to be includet in to the statistics evaluation\n\nmin_length - minimal value of alonglengthcoordinate to be includet in to the statistics evaluation\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.angular_distribution_statistics_plot-Tuple{DistributionStatistics}","page":"API","title":"ThermovisorImages.angular_distribution_statistics_plot","text":"angular_distribution_statistics_plot(ds::DistributionStatistics;\n            show_lower_bound::Bool=true,\n            show_upper_bound::Bool=true,\n            show_std::Bool=true,\n            probability::Float64=0.95,\n            is_use_student::Bool=true,\n            length_scaler::Float64=1.0,\n            label=nothing,\n            minorgrid=true,\n            gridlinewidth=2,\n            title=\"Average temperature angular distribution\",framestyle = :box,\n            dpi=600,xlabel = \"Angle , °\", ylabel=\"Temperature, °C\",\n            kwargs...)\n\nThe same as radial_distribution_statistics_plot but plots averaged angular distribution\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.area-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.area","text":"area(c::CentredObj)\n\nEaluates the surface area in pixels\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.areas-Tuple{MarkeredImage}","page":"API","title":"ThermovisorImages.areas","text":"areas(m::MarkeredImage)\n\nVector of patterns areas (number of pixels within the pattern)\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.c_view-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"ThermovisorImages.c_view","text":"c_view(img::AbstractMatrix,c::CentredObj)\n\nReturns the view of img elements which are within the CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.cent_to_flag-Union{Tuple{T}, Tuple{T, Tuple{Int64, Int64}}} where T<:CentredObj","page":"API","title":"ThermovisorImages.cent_to_flag","text":"cent_to_flag(c::CentredObj,sz::Tuple{Int,Int};external=false)\n\nConverts CentredObj to bitmatrix  of size sz\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.cent_to_flag-Union{Tuple{T}, Tuple{Type{T}, CentredObj, Tuple{Int64, Int64}}} where T<:Union{BitMatrix, Matrix{Bool}}","page":"API","title":"ThermovisorImages.cent_to_flag","text":"cent_to_flag(::Type{T},c::CentredObj,sz::Tuple{Int,Int};external=false) where T<:FlagMatrix\n\nConverts centred obj to BitMatrix or the Matrix of bool see `FlagMatrix\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.center-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.center","text":"center(c::CentredObj)\n\nVector of object center coordinates (MVector)\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.change_default_colorscheme-Tuple{Symbol}","page":"API","title":"ThermovisorImages.change_default_colorscheme","text":"change_default_colorscheme(new_scheme::Symbol)\n\nChange colorschee which is used by default to convert matrices to rgb images\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.change_default_roi_color-Tuple{ColorTypes.RGB{Float64}}","page":"API","title":"ThermovisorImages.change_default_roi_color","text":"change_default_roi_color(color::RGB{Float64})\n\nChanges default color to visualize the CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.convert_temperature_to_emissivity-Tuple{AbstractMatrix, Float64, Float64}","page":"API","title":"ThermovisorImages.convert_temperature_to_emissivity","text":"convert_temperature_to_emissivity(image::AbstractMatrix,\n                                        real_temperature::Float64,\n                                        image_emissivity::Float64;\n                                        λ_left::Union{Float64,Nothing}=14.0,\n                        λ_right::Union{Float64,Nothing}=14.5,\n                        is_in_kelvins::Bool=false)\n\nEvaluates the emissivity, assuming the whole image to be of the same temperature real_temperature. If both λleft and λright are not equal and none of them is nothing the emissivity ϵ is calculated using:\n\nϵ =  image_emissivity⋅∫iᵦ(λ,Tᵣ)dλ/∫iᵦ(λ,Tₘ)dλ\n\nHere iᵦ is the Planck spectral radiance, Tₘ is the measured temperature (value of pixel temperature), Tᵣ is the real temperature of the surface. The integration is preformed over the [λ_left,λ_right] spectral range with the help of band_power function provied by the PlanckFunctions package. \n\nIf one of (but not both) λleft and λright is set to nothing or both of them are equal, than the following equaion is solved:\n\nϵ =  image_emissivity⋅iᵦ(λ,Tᵣ)/iᵦ(λ,Tₘ)\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.convert_to_drawable-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.convert_to_drawable","text":"convert_to_drawable(::CentredObj)\n\nConverts CentredObj to a drawable structure appropriate to the ImageDraw draw function, polygon,ellipse see [ImageDraw.draw] function \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.copyobj-Tuple{T} where T<:CentredObj","page":"API","title":"ThermovisorImages.copyobj","text":"copyobj(c::T) where T<:CentreObj\n\nCopies the CentredObj creating new instance\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.count_separate_patterns-Tuple{Matrix{Int64}}","page":"API","title":"ThermovisorImages.count_separate_patterns","text":"count_separate_patterns(markers::Matrix{Int})\n\nThis function takes matrix of markers see marker_image and calculates the number of separate patterns\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.diagonal_points-Tuple{Union{CircleObj, SquareObj}}","page":"API","title":"ThermovisorImages.diagonal_points","text":"diagonal_points(c::Union{SquareObj,CircleObj})\n\nReturns diagonal points in row-column coordinates\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw!-Tuple{Matrix{ColorTypes.RGB{Float64}}, CentredObj}","page":"API","title":"ThermovisorImages.draw!","text":"draw!(rgbim::Matrix{RGB{Float64}},\n                c::CentredObj;\n                fill=false,\n                thickness::Int=55,\n                roi_color::RGB{Float64}=DefRoiColor[],\n                show_cross::Bool=true,\n                kwargs...)\n\nDraws c inside the image rgbim (modified) \n\nKeyword arguments: \n\nfill - if true fills the object \n\nthickness - thickness of c boundary \n\n(this two arguments are transfered to convert_to_drawable) \n\nroi_color - RGB color of ROI boundary and filling  \n\nshow_cross - if true the cross is displayed \n\nkwargs - Other keyword arguments are transfered directly to the ImageDraw.draw! function\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.draw","text":"draw(c::CentredObj;kwargs...)\n\nReturns CentredObj image of minimal possible size\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw-Tuple{Matrix{Float64}, CentredObj}","page":"API","title":"ThermovisorImages.draw","text":"draw(image::Matrix{Float64},c::CentredObj;fill=false,thickness::Int=-1,\n                                    roi_color::RGB{Float64}=DefRoiColor[], \n                                    color_scheme::Symbol=:none,\n                                    show_cross=true,kwargs...)\n\nConverts image to RGB (if not all values of the image are within [0,1]  - rescales) \n\nAnd draws CentreObj c inside the image (does not affect the values of image)\n\nFor kwargs see draw!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw-Tuple{RescaledImage, CentredObj}","page":"API","title":"ThermovisorImages.draw","text":"draw(image::RescaledImage,c::CentredObj)\n\nConverts image to RGB and draws CentredObj in it. For kwargs see draw!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw-Union{Tuple{T}, Tuple{RescaledImage, Vector{T}}} where T<:CentredObj","page":"API","title":"ThermovisorImages.draw","text":"draw(image::RescaledImage,c::Vector{T};kwargs...) where T<:CentredObj\n\nConverts image to RGB and draws multiple objects\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.draw_line_within_mask-Tuple{Matrix{Float64}, CentredObj, Any, Any}","page":"API","title":"ThermovisorImages.draw_line_within_mask","text":"draw_line_within_mask(image::Matrix{Float64},c::CentredObj,\n                ang,length;thickness::Int=55,\n                roi_color::RGB{Float64}=DefRoiColor[], \n                color_scheme::Symbol=:none,kwargs...)\n\nDraws straight line on the image converted to RGB, all points are located within the CentredObj. This line goes through the centre of c and oriented with the angle ang in degrees with positive direction  - counterclockwise.\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.eval_bounds-Tuple{DistributionStatistics}","page":"API","title":"ThermovisorImages.eval_bounds","text":"eval_bounds(DS::DistributionStatistics;is_use_student::Bool=true)\n\nEvaluates confidence bounds\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.external_flag-Union{Tuple{T}, Tuple{MarkeredImage, Int64}, Tuple{MarkeredImage, Int64, Type{T}}} where T<:Union{BitMatrix, Matrix{Bool}}","page":"API","title":"ThermovisorImages.external_flag","text":"external_flag(m::MarkeredImage,i::Int,::Type{T}=Matrix{Bool}) where T<:FlagMatrix\n\nInversed version of flag (by default returns matrix of bool)\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_from_vect!-Tuple{CentredObj, AbstractVector}","page":"API","title":"ThermovisorImages.fill_from_vect!","text":"fill_from_vect!(c::CentredObj, v::AbstractVector)\n\nFills CentreObj parameters from the vector [centerindex1,centerindex2,dimension1,dimension2,...]\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_im!-Tuple{Union{BitMatrix, Matrix{Bool}}, CentredObj}","page":"API","title":"ThermovisorImages.fill_im!","text":"fill_im!(img,c::CentredObj)\n\nFills bitmatrix or the matrix of Bool img in a way that all pixels which are  within the CentredObj are true and false otherwise.  \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_im_external!-Tuple{Union{BitMatrix, Matrix{Bool}}, CentredObj}","page":"API","title":"ThermovisorImages.fill_im_external!","text":"fill_im_external!(img::FlagMatrix,c::CentredObj)\n\nFills image matrix img in a way that all pixels which are  not within the CentreObj set to true.  See also is_within\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_vect!-Tuple{AbstractVector, CentredObj}","page":"API","title":"ThermovisorImages.fill_vect!","text":"fill_vect!(x::AbstractVector, c::CentredObj)\n\nConverts CentredObj to vector\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_x0!-Tuple{Any, Union{BitMatrix, Matrix{Bool}}, CentredObj}","page":"API","title":"ThermovisorImages.fill_x0!","text":"fill_x0!(x0,im_bin::AbstractMatrix,c::CentredObj)\n\nFills the optimization starting vector by seraching the centre of the image im_bin\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fill_x0!-Tuple{Any, Union{BitMatrix, Matrix{Bool}}, CircleObj}","page":"API","title":"ThermovisorImages.fill_x0!","text":"fill_x0!(x0,im_bin::FlagMatrix,::CircleObj)\n\nFills starting vector for the optimization of CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.filter_image!-Tuple{AbstractMatrix, Union{BitMatrix, Matrix{Bool}}}","page":"API","title":"ThermovisorImages.filter_image!","text":"filter_image!(imag::AbstractMatrix,flag::BitMatrix)\n\nReturns FilteredImage taking all elements of imag which are not externalregionflag\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.filter_image!-Tuple{RescaledImage, Union{BitMatrix, Matrix{Bool}}}","page":"API","title":"ThermovisorImages.filter_image!","text":"filter_image!(imag::RescaledImage{Float64},external_region_flag::FlagMatrix)::FilteredImage\n\nIn-place filtering of RescaledImage, filtered object is wrapped around the input RescaledImage\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.filter_image-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"ThermovisorImages.filter_image","text":"filter_image(imag::AbstractMatrix,c::CentredObj;external=false)\n\nFilters image according to centered object creating new image if external  is true than as a filtering flag the inverse of centered object image is taken\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.filter_image-Tuple{RescaledImage, CentredObj}","page":"API","title":"ThermovisorImages.filter_image","text":"filter_image(imag::RescaledImage,c::CentredObj;external=false)\n\nFilters image according \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.filter_image-Tuple{RescaledImage, MarkeredImage}","page":"API","title":"ThermovisorImages.filter_image","text":"filter_image(imag::RescaledImage,markers;label=0)\n\nFuntion zeroes all pixels of the image, except those belonging to the specified pattern. image - rescaled image (see RescaledImage type) markers - the matrix of the same size as the input image, each element of this matrix has unique value-label associated with some pattern.  Function label_components returns the markers matrix. (optional) - the value of the label to be selected as a pattern marker\n\nFunction returns FilteredImage object\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.find_temperature_files","page":"API","title":"ThermovisorImages.find_temperature_files","text":"    `find_temperature_files(folder::AbstractString)`\n\nSearchs the folder for thermal images files using is_temperature_file Returns dictionary Dict{String,Pair{Float64,String}} with keys parts of files matched  using is_temperature_file, values - are temperature pairs of Float64 => full-file-name When file name contains \"BB\" it supposed to be the blackbody themperature distribution       \n\n\n\n\n\n","category":"function"},{"location":"ThermovisorImages/#ThermovisorImages.fit_all_patterns!-Union{Tuple{MarkeredImage}, Tuple{T}, Tuple{MarkeredImage, Type{T}}} where T<:CentredObj","page":"API","title":"ThermovisorImages.fit_all_patterns!","text":"fit_all_patterns(img::RescaledImage,::Type{T}=CircleObj;\n                                        level_threshold::Float64=-1.0,\n                                        distance_threshold::Float64=-15.0,\n                                        max_centred_objs::Int=200,\n                                        sort_by_area::Bool = false,\n                                        is_descend::Bool = true,\n                                        optimizer::Optim.ZerothOrderOptimizer = NelderMead(),\n                                        options::Optim.Options=DEFAULT_FITTING_OPTIONS[]) where T<:CentredObj\n\nFunction fits all patterns of the image img to the vector of CentredObj ROI objects.  The type of ROI should be provided as a second arguments (by default it is a CircleObj)\n\nimg - input image of RescaledImage type\n\nFor other input arguments see marker_image and fit_centred_obj!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fit_all_patterns!-Union{Tuple{T}, Tuple{Vector{T}, MarkeredImage}, Tuple{Vector{T}, MarkeredImage, Any}, Tuple{Vector{T}, MarkeredImage, Any, Any}, Tuple{Vector{T}, MarkeredImage, Any, Any, Bool}} where T<:CentredObj","page":"API","title":"ThermovisorImages.fit_all_patterns!","text":"fit_all_patterns!(c_vect::Vector{T},\n                        markers::MarkeredImage,\n                        optimizer::Optim.ZerothOrderOptimizer = NelderMead(),\n                        options::Optim.Options=DEFAULT_FITTING_OPTIONS[]) where T<:CentredObj\n\nFits markered image pattern and fills precreated avector of Centerdobjs See fit_all_patterns!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fit_all_patterns-Union{Tuple{RescaledImage}, Tuple{T}, Tuple{RescaledImage, Type{T}}} where T<:CentredObj","page":"API","title":"ThermovisorImages.fit_all_patterns","text":"fit_all_patterns(img::RescaledImage,::Type{T}=CircleObj;\n                                level_threshold::Float64=-1.0,\n                                distance_threshold::Float64=-15.0,\n                                max_centred_objs::Int=200,\n                                sort_by_area::Bool = false,\n                                is_descend::Bool = true,\n                                optimizer::Optim.ZerothOrderOptimizer = NelderMead(),\n                                options::Optim.Options=DEFAULT_FITTING_OPTIONS[]) where T<:CentredObj\n\nMarkers RescaledImage and fits all patterns See fit_all_patterns!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.fit_centred_obj!","page":"API","title":"ThermovisorImages.fit_centred_obj!","text":"fit_centred_obj!(c::CentredObj,image::FilteredImage;kwargs...)\n\nFits CentredObj (modified) to filtered image (not modified) fit_reduced flag (default=true) indicates what version of the image should be fitted if true -  reduced otherwise - full image. For other input arguments see fit_centred_obj!\n\n\n\n\n\n","category":"function"},{"location":"ThermovisorImages/#ThermovisorImages.fit_centred_obj!-Tuple{CentredObj, Union{BitMatrix, Matrix{Bool}}}","page":"API","title":"ThermovisorImages.fit_centred_obj!","text":"fit_centred_obj!(c::CentredObj,im_bin::FlagMatrix;\n                            starting_point::Union{Nothing,Vector{Float64}}=nothing,\n                            optimizer::Optim.ZerothOrderOptimizer = Optim.NelderMead(), \n                            options::Optim.Options=DEFAULT_FITTING_OPTIONS[],refit::Bool = true)\n\nFits CentredObj to binary image pattern (region of units) by adjusting centre coordinates and dimensions using zeroth-order optimizers from Optim.jl package.\n\nInput variables:\n\nc - CentredObj (modified)   \n\nim_bin - binarized image (BitMatrix or Matrix{Bool})\n\n(optional)\n\nstartingpoint - staring vector (uses [`fillx0!`](@ref) function to fill starting point by default)\n\noptimizer - zeroth-order optimizer from Optim.jl package\n\noptions  - optimization options from Optim.jl package\n\nrefit - if true the starting point of the optimization recalculated otherwise it is taken from the current state vector of ROI\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.flag!-Union{Tuple{T}, Tuple{T, MarkeredImage, Int64}} where T<:Union{BitMatrix, Matrix{Bool}}","page":"API","title":"ThermovisorImages.flag!","text":"flag!(fl::FlagMatrix,m::MarkeredImage,i::Int;negate::Bool=false)\n\nFills the fl matrix (Bitmatrix or Matrix{Bool}) with the same size  as the entire image with all elements set to zero, except the pixels of i'th pattern\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.flag-Union{Tuple{T}, Tuple{MarkeredImage, Int64}, Tuple{MarkeredImage, Int64, Type{T}}} where T<:Union{BitMatrix, Matrix{Bool}}","page":"API","title":"ThermovisorImages.flag","text":"flag(m::MarkeredImage,i::Int,::Type{T}=Matrix{Bool}) where T<:FlagMatrix\n\nCreates matrix of Bool or Bitmatrix with the same size as the whole markers matrx with trues on the  location of i'th pattern\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.full_image_flag-Union{Tuple{FilteredImage}, Tuple{T}, Tuple{FilteredImage, Type{T}}} where T<:Union{BitMatrix, Matrix{Bool}}","page":"API","title":"ThermovisorImages.full_image_flag","text":"full_image_flag(filtered_im::FilteredImage)\n\nReturns the BitMatrix flag of filtered pattern in the whole image.\n\nCan be used as index matrix in the full image:\n\nfiltered_image.full.initial[full_image_flag(filtered_image)] will return   all elements which belong to the pattern\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.generate_random_objs!-Union{Tuple{R}, Tuple{T}, Tuple{Matrix{Float64}, Type{T}, Int64, R}} where {T<:CentredObj, R<:StepRange{Int64, Int64}}","page":"API","title":"ThermovisorImages.generate_random_objs!","text":"generate_random_objs!(im::Matrix{Float64},::Type{T},obj_number::Int,dimension_range::R) where {T<:CentredObj,R<:StepRange{Int,Int}}\n\nGenerates random objects on the image im see generate_random_objs\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.generate_random_objs-Union{Tuple{R}, Tuple{T}, Tuple{Type{T}, Tuple{R, R}, Int64, R}} where {T<:CentredObj, R<:StepRange{Int64, Int64}}","page":"API","title":"ThermovisorImages.generate_random_objs","text":"generate_random_objs(::Type{T},centers_range::NTuple{2,R},obj_number::Int,dimension_range::R) where {T<:CentredObj,R<:StepRange{Int,Int}}\n\nGenerates obj_number of objects of CentredObj subtype  specified by the first argument,  Second argument centers_range is a tuple of StepRange s for x and y coordinates of center  to be taken from randomly, and dimension_range is the range for dimensions\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.image_discr-Tuple{Any, Any}","page":"API","title":"ThermovisorImages.image_discr","text":"image_discr(im1,im2)\n\nCalculates the scalar distance between two matrices by checking the equality of their elements\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.image_fill_discr-Tuple{Union{BitMatrix, Matrix{Bool}}, CentredObj}","page":"API","title":"ThermovisorImages.image_fill_discr","text":"image_fill_discr(image::FlagMatrix,c::CentredObj)\n\nFunction returns the function to evaluate the discrepancy  between  CentredObj and the matrix, this function is used during the fitting procedure \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.is_temperature_file-Tuple{AbstractString}","page":"API","title":"ThermovisorImages.is_temperature_file","text":"    is_temperature_file(file_name::AbstractString)\n\nChecks if the file with file_name has an appropriate name for thermovisor temperature distribution file\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.is_within-Tuple{CentredObj, Any}","page":"API","title":"ThermovisorImages.is_within","text":"is_within(c::CentredObj,_)\n\nFunction to check if indices are within CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.is_within-Tuple{CentredObj, CartesianIndex}","page":"API","title":"ThermovisorImages.is_within","text":"is_within(c::CentredObj,i::CartesianIndex)\n\nCartesianIndex support\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.is_within_iterator-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"ThermovisorImages.is_within_iterator","text":"is_within_iterator(img::AbstractMatrix,c::CentredObj)\n\nIterator over all CartesianIndices within the img which are within the CentredObj c\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.line_points_to_along_length-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T","page":"API","title":"ThermovisorImages.line_points_to_along_length","text":"line_points_to_along_length(along_line_points::Vector{T},line_points) where T\n\nConverts Cartesian indices of along_line_points to the length along line\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.line_within_mask-Tuple{CentredObj, Float64, Int64}","page":"API","title":"ThermovisorImages.line_within_mask","text":"line_within_mask(c::CentredObj,ang::Float64,line_length::Int)\n\nFunction returns endpoint of the line lying fully within the mask  - tuple of four point which can be  directly splatted to the alonglinedistribution\n\nang - angle in degrees \n\nline_length - the length of line   \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.line_within_mask-Tuple{CircleObj, Any, Any}","page":"API","title":"ThermovisorImages.line_within_mask","text":"line_within_mask(c::CircleObj,ang,line_length)\n\nReturns two endpoints of the line lying totally inside the CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.m_view-Tuple{AbstractMatrix, MarkeredImage, Int64}","page":"API","title":"ThermovisorImages.m_view","text":"m_view(im::AbstractMatrix,m::MarkeredImage,i::Int)\n\nReturns the view of matrix im at points corresponding to the  i th pattern of MarkeredImage image m \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.m_view-Tuple{MarkeredImage, Int64}","page":"API","title":"ThermovisorImages.m_view","text":"m_view(m::MarkeredImage,i::Int)\n\nReturns the view of specified marker in m.markers\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.marker_image-Tuple{RescaledImage}","page":"API","title":"ThermovisorImages.marker_image","text":"marker_image(rescaled::RescaledImage,level_threshold::Float64,distance_threshold::Float64=1e-3)\n\nMarkers image patterns, input umage is of RescaledImage image type,  levelthreshold  - should be between 0.0 and 1.0 distancethreshold  - criterium of image binarization after distance transform, should be less than 1\n\nreturns MarkeredImage object\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.mean_within_mask-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"ThermovisorImages.mean_within_mask","text":"mean_within_mask(img::AbstractMatrix,c::CentredObj)\n\nEvaluates the average temperature of all points within the CentredObj marker\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.obj_from_vect-Union{Tuple{T}, Tuple{Type{T}, AbstractVector}} where T<:CentredObj","page":"API","title":"ThermovisorImages.obj_from_vect","text":"obj_from_vect(::Type{CentredObj},v::AbstractVector)\n\nCreates object from parameters vector, first two arguments are center point other are dimensions [center[1],center[2],dimensions[1],...]\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.parnumber-Union{Tuple{Type{T}}, Tuple{T}} where T<:CentredObj","page":"API","title":"ThermovisorImages.parnumber","text":"parnumber(::Type{T}) where T<:CentredObj\n\nReturns total number of parameters needed to create new object\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.perimeter-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.perimeter","text":"perimeter(c::CentredObj)\n\nReturns perimeter of the object\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.points_within_line!-Tuple{AbstractMatrix, AbstractVector}","page":"API","title":"ThermovisorImages.points_within_line!","text":"points_within_line!(imag::AbstractMatrix,line_points::AbstractVector)\n\nForces all line points to lie within the possible region according to the image size\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.radial_distribution-Tuple{AbstractMatrix, CentredObj, AbstractRange}","page":"API","title":"ThermovisorImages.radial_distribution","text":"radial_distribution(imag::AbstractMatrix,c::CentredObj,angles_range::AbstractRange,line_length;mm_per_pixel=1.0)\n\nCalls along_mask_line_distribution on lines oriented with some angles range and puts the resulting  distribution into one matrix j'th column of this matrix corresponds to the distribution along the  line oriented with ang[j] angle. The length of line is line_length, if it is less than 0.0 or greater  than the smallest dimension of c, than is is set to the smallest dimentsion of c\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.radial_distribution_statistics-Tuple{AbstractVector, AbstractVecOrMat}","page":"API","title":"ThermovisorImages.radial_distribution_statistics","text":"radial_distribution_statistics(along_length_coordinate::AbstractVector,\n    distrib::AbstractVecOrMat;\n    max_length=-1.0,min_length=-1.0)\n\nFills DistributionStatistics object for radial distribution\n\nOptional:\n\nmax_length - maximal value of alonglengthcoordinate to be includet in to the statistics evaluation\n\nmin_length - minimal value of alonglengthcoordinate to be includet in to the statistics evaluation\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.radial_distribution_statistics_plot-Tuple{DistributionStatistics}","page":"API","title":"ThermovisorImages.radial_distribution_statistics_plot","text":"radial_distribution_statistics_plot(ds::DistributionStatistics;\n            show_lower_bound::Bool=false,\n            show_upper_bound::Bool=false,\n            show_std::Bool=true,\n            is_use_student::Bool=true,\n            probability::Float64=0.95,\n            length_scaler::Float64=1.0,\n            is_centered::Bool=true,\n            bound_color::Symbol=:red,\n            # plot kwargs\n            label::Union{AbstractString,Nothing} =nothing,\n            minorgrid::Bool=true,\n            gridlinewidth=2,\n            title::Union{AbstractString,Nothing} =\"Average temperature radial distribution\",\n            framestyle::Symbol = :box,\n            dpi::Int=600,\n            xlabel::Union{AbstractString,Nothing} = \"Distance  across the sample ,mm\", \n            ylabel::Union{AbstractString,Nothing}  =  \"Temperature °C\",\n            kwargs...)\n\nRecipe to plot the distribution statistics DistributionStatistics object. Returns structure of StatDataPlot type, which has attached recipe to plot  radial ditribution averaged value, lower and upper confidence bounds as <d> ± std (if show_std is true) and confidence bounds multiplied by the Student's coefficient (if showlowerbound and showupperbound are true) calculated for the pobability value,  if length_scaler is provied all coordinates are multiplied by this value (can be used to convert pixels to actual units) If is_centered is true coordinate goes from -L/2 to +L/2 where L is the maximum of coordinates. Other key-word arguments are the same as for the plot functions, additional keyword arguments are transfered directly to the plot function Usage example:\n\n    using Plots\n    plot(radial_distribution_statistics_plot(distribution_statistics))\n\n\nThis code will plot the averaged distribution statistics together with confidence bounds\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.read_temperature_file-Tuple{AbstractString}","page":"API","title":"ThermovisorImages.read_temperature_file","text":"read_temperature_file(f_name::AbstractString;inverse_intensity::Bool=false)\n\nReads temeprature file f_name is a full file name, inverse_intensity is true if  the intensities in the loaded file should be inverted\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.rearranged_diagonal-Tuple{Union{CircleObj, SquareObj}}","page":"API","title":"ThermovisorImages.rearranged_diagonal","text":"rearranged_diagonal(c::Union{SquareObj,CircleObj})\n\nReturns diagonal points in x-y coordinates\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.recalculate_with_new_emissivity!-Tuple{AbstractArray, CentredObj, Float64, Float64}","page":"API","title":"ThermovisorImages.recalculate_with_new_emissivity!","text":"recalculate_with_new_emissivity!(image::AbstractArray,c::CentredObj,new_emissivity::Float64;\n                                            kwargs...)\n\nRecalculates temperarture of each pixel within the CentredObj with new_emissivity see recalculate_with_new_emissivity! for keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.recalculate_with_new_emissivity!-Tuple{AbstractArray, Float64, Float64}","page":"API","title":"ThermovisorImages.recalculate_with_new_emissivity!","text":"recalculate_with_new_emissivity!(image::AbstractArray,new_emissivity::Float64,\n                                    image_emissivity::Float64;\n                                    λ_left::Union{Float64,Nothing}=14.0,\n                                    λ_right::Union{Float64,Nothing}=14.5,\n                                    is_in_kelvins::Bool=false,\n                                    rel_tol::Float64=1e-3)\n\nFunction recalculates all temperatures in image assuming the temperatures were measured  for the surface with emissivity image_emissivity; new_emissivity is a new value of   emissivity, λ_left and λ_right are left and right wavelength boundaries of infrared camera spectral range in μm. If is_in_kelvins is false (default) all temperatures supposed to be in Celsius and  Kelvins otherwise.\n\nTo find a new temperature value T the function solves a non-linear equation. If both λleft and λright are not equal and none of them is nothing, the following equation is solved:\n\nnew_emissivity ⋅∫iᵦ(λ,T)dλ = image_emissivity ⋅∫iᵦ(λ,Tₘ)dλ\n\nHere iᵦ is the Planck spectral radiance, Tₘ is the measured temperature (value of pixel intensity). The integration is preformed over the [λ_left,λ_right] spectral range with the help of band_power function provied by the PlanckFunctions package. \n\nIf one of (but not both) λleft and λright is set to nothing or both of them are equal, than the following equaion is solved:\n\nnew_emissivity⋅iᵦ(λ,T) = image_emissivity⋅iᵦ(λ,Tₘ)\n\nIn both cases the equation is solved by minimizing the univariate function of least-square  difference of left and right parts of the equation. Second version of equation is much faster, but less precise.\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.recalculate_with_new_emissivity!-Tuple{AbstractArray, MarkeredImage, Int64, Float64, Float64}","page":"API","title":"ThermovisorImages.recalculate_with_new_emissivity!","text":"recalculate_with_new_emissivity!(image::AbstractArray,marker::MarkeredImage,\n    label::Int,new_emissivity::Float64,image_emissivity::Float64;\n    kwargs...)\n\nRecalculates the temperarture of each pixel within image pattern label of MarkeredImage image marker with new_emissivity assuming image_emissivity be the emissvity settled during measurements. Both marker and image should be of the same size. See recalculate_with_new_emissivity!\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.revcentre-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.revcentre","text":"revcentre(c::CentredObj)\n\nObject coordinates in reverse order\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.shift!-Union{Tuple{T}, Tuple{T, CartesianIndex{2}}} where T<:CentredObj","page":"API","title":"ThermovisorImages.shift!","text":"shift!(c::CentredObj,ind::CartesianIndex{2})\n\nRelative shift of centred object center\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.shrinked_flag-Tuple{MarkeredImage, Int64}","page":"API","title":"ThermovisorImages.shrinked_flag","text":"reduced_flag(m::MarkeredImage,i::Int)\n\nreturns flag matrix shrinked to the size of the pattern\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.side-Tuple{CentredObj}","page":"API","title":"ThermovisorImages.side","text":"side(c::CentredObj)\n\nReturns the side of CentredObj\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.sort_markers!","page":"API","title":"ThermovisorImages.sort_markers!","text":"sort_markers!(m::MarkeredImage,descending::Bool=true)\n\nSorts markers, see sort_reduce!\n\n\n\n\n\n","category":"function"},{"location":"ThermovisorImages/#ThermovisorImages.sort_reduce!-Tuple{MarkeredImage}","page":"API","title":"ThermovisorImages.sort_reduce!","text":"sort_reduce!(m::MarkeredImage;total_number::Int = -1,descending::Bool=true)\n\nSorts markers by total area and reduces the total number of patterns if the maximum label is less then total_number value\n\nInput arguments: m - MarkeredImage total_number - number of patterns retained in the image\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.std_within_mask-Tuple{AbstractMatrix, CentredObj}","page":"API","title":"ThermovisorImages.std_within_mask","text":"std_within_mask(img::AbstractMatrix, c::CentredObj)\n\nEvaluates standard deviation of temperature for all points within the CentredObj marker\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.student_coefficient-Tuple{Int64, Any}","page":"API","title":"ThermovisorImages.student_coefficient","text":"student_coefficient(degrees_of_freedom::Int, probability; digits::Int = 3, side::Int = 2)\n\nEvaluates Student's distribution coefficient\n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.to_rgb-Tuple{Matrix{Float64}}","page":"API","title":"ThermovisorImages.to_rgb","text":"to_rgb(image::Matrix{Float64};color_scheme::String=\"\")\n\nConverts matrix to rgb - martix by applyting the color scheme  from ColorSchemes package. \n\n\n\n\n\n","category":"method"},{"location":"ThermovisorImages/#ThermovisorImages.within_mask_line_points_distribution","page":"API","title":"ThermovisorImages.within_mask_line_points_distribution","text":"within_mask_line_points_distribution(imag::AbstractMatrix,c::CentredObj,direction_angle=0.0,line_length=10.0;use_wu::Bool=false)\n\nEvaluates the distribution of values in imag matrix along the line with length line_length in pixels oriented with the angle direction_angle in degrees  with respect to the posistive direction of oX (column index increase),  this line lies within the roi (CentreObj) and goes through its center.\n\nFunction returns: a Tuple (points,distrib,linepoints)\n\npoints  - vector of CartesianIndex of image's points lying on the line\n\ndistrib - distribution of values\n\nlinepoints - endpoints of line the Tupple of (leftx,leftY,rightx,righty)\n\n\n\n\n\n","category":"function"},{"location":"Examples/","page":"Examples","title":"Examples","text":"<p>The static version (with no interactive elements) of Pluto notebook with <b>ThermovisorImages.jl</b> usage is available at: <a href=\"../ThermovisorImages-test.html\">ThermovisorImages.html</a>\n.</p","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Notebook file itself is available at Pluto notebooks.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To run these notebooks, you need:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Install julia language itself from its official download page \nInstall Pluto notebook from julia REPL by entering the following commands ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"line-by-line:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import Pkg\nPkg.add(\"Pluto\")\nusing Pluto\nPluto.run()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The last line will launch the Pluto starting page in your default browser ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Copy/Clone the entire GitHub repository to your local folder. As far as ThermovisorImages.jl is not a registered package, all files needed to run the notebooks must be in the ../notebooks folder with respect to  note_book_name.jl file location.\nOpen notebook's .jl- file in Pluto by providing the full path to the \"Open a notebook\" text field on Pluto's starting page. As far as Pluto has its own package manager, it will automatically install all necessary dependancies, which are marked in using cell of this file. ","category":"page"},{"location":"#ThermovisorImages.jl","page":"Home","title":"ThermovisorImages.jl","text":"","category":"section"},{"location":"#General-description","page":"Home","title":"General description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ThermovisorImages.jl is designed to process static thermal images stored as matrices in CSV files or as image files. It treats each matrix element as a temperature value. ThermovisorImages.jl provides functions to calculate temperature distributions and perform statistical analyses of temperatures within Regions of Interest (ROIs), such as circles, squares, rectangles, or along lines. ROI objects can be fitted to image patterns (regions that stand out from the background). It is also possible to evaluate statistics across multiple ROIs, including distributions of side length, area, and perimeter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ThermovisorImages.jl also provides functions to recalculate the temperature distribution of the entire image (or its part within the ROI or labeled pattern), taking into account the emissivity of the surface and the spectral range of the infrared camera.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contacts GitHub repository.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) 2025 Roman Mironov","category":"page"},{"location":"","page":"Home","title":"Home","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.","category":"page"}]
}
